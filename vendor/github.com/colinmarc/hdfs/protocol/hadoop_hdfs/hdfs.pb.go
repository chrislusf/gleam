// Code generated by protoc-gen-go.
// source: hdfs.proto
// DO NOT EDIT!

package hadoop_hdfs

import proto "github.com/golang/protobuf/proto"
import math "math"
import hadoop_common "github.com/colinmarc/hdfs/protocol/hadoop_common"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// *
// Types of recognized storage media.
type StorageTypeProto int32

const (
	StorageTypeProto_DISK     StorageTypeProto = 1
	StorageTypeProto_SSD      StorageTypeProto = 2
	StorageTypeProto_ARCHIVE  StorageTypeProto = 3
	StorageTypeProto_RAM_DISK StorageTypeProto = 4
)

var StorageTypeProto_name = map[int32]string{
	1: "DISK",
	2: "SSD",
	3: "ARCHIVE",
	4: "RAM_DISK",
}
var StorageTypeProto_value = map[string]int32{
	"DISK":     1,
	"SSD":      2,
	"ARCHIVE":  3,
	"RAM_DISK": 4,
}

func (x StorageTypeProto) Enum() *StorageTypeProto {
	p := new(StorageTypeProto)
	*p = x
	return p
}
func (x StorageTypeProto) String() string {
	return proto.EnumName(StorageTypeProto_name, int32(x))
}
func (x *StorageTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StorageTypeProto_value, data, "StorageTypeProto")
	if err != nil {
		return err
	}
	*x = StorageTypeProto(value)
	return nil
}

// *
// Cipher suite.
type CipherSuiteProto int32

const (
	CipherSuiteProto_UNKNOWN           CipherSuiteProto = 1
	CipherSuiteProto_AES_CTR_NOPADDING CipherSuiteProto = 2
)

var CipherSuiteProto_name = map[int32]string{
	1: "UNKNOWN",
	2: "AES_CTR_NOPADDING",
}
var CipherSuiteProto_value = map[string]int32{
	"UNKNOWN":           1,
	"AES_CTR_NOPADDING": 2,
}

func (x CipherSuiteProto) Enum() *CipherSuiteProto {
	p := new(CipherSuiteProto)
	*p = x
	return p
}
func (x CipherSuiteProto) String() string {
	return proto.EnumName(CipherSuiteProto_name, int32(x))
}
func (x *CipherSuiteProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CipherSuiteProto_value, data, "CipherSuiteProto")
	if err != nil {
		return err
	}
	*x = CipherSuiteProto(value)
	return nil
}

// *
// Crypto protocol version used to access encrypted files.
type CryptoProtocolVersionProto int32

const (
	CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION CryptoProtocolVersionProto = 1
	CryptoProtocolVersionProto_ENCRYPTION_ZONES         CryptoProtocolVersionProto = 2
)

var CryptoProtocolVersionProto_name = map[int32]string{
	1: "UNKNOWN_PROTOCOL_VERSION",
	2: "ENCRYPTION_ZONES",
}
var CryptoProtocolVersionProto_value = map[string]int32{
	"UNKNOWN_PROTOCOL_VERSION": 1,
	"ENCRYPTION_ZONES":         2,
}

func (x CryptoProtocolVersionProto) Enum() *CryptoProtocolVersionProto {
	p := new(CryptoProtocolVersionProto)
	*p = x
	return p
}
func (x CryptoProtocolVersionProto) String() string {
	return proto.EnumName(CryptoProtocolVersionProto_name, int32(x))
}
func (x *CryptoProtocolVersionProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoProtocolVersionProto_value, data, "CryptoProtocolVersionProto")
	if err != nil {
		return err
	}
	*x = CryptoProtocolVersionProto(value)
	return nil
}

// *
// Checksum algorithms/types used in HDFS
// Make sure this enum's integer values match enum values' id properties defined
// in org.apache.hadoop.util.DataChecksum.Type
type ChecksumTypeProto int32

const (
	ChecksumTypeProto_CHECKSUM_NULL   ChecksumTypeProto = 0
	ChecksumTypeProto_CHECKSUM_CRC32  ChecksumTypeProto = 1
	ChecksumTypeProto_CHECKSUM_CRC32C ChecksumTypeProto = 2
)

var ChecksumTypeProto_name = map[int32]string{
	0: "CHECKSUM_NULL",
	1: "CHECKSUM_CRC32",
	2: "CHECKSUM_CRC32C",
}
var ChecksumTypeProto_value = map[string]int32{
	"CHECKSUM_NULL":   0,
	"CHECKSUM_CRC32":  1,
	"CHECKSUM_CRC32C": 2,
}

func (x ChecksumTypeProto) Enum() *ChecksumTypeProto {
	p := new(ChecksumTypeProto)
	*p = x
	return p
}
func (x ChecksumTypeProto) String() string {
	return proto.EnumName(ChecksumTypeProto_name, int32(x))
}
func (x *ChecksumTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChecksumTypeProto_value, data, "ChecksumTypeProto")
	if err != nil {
		return err
	}
	*x = ChecksumTypeProto(value)
	return nil
}

type DatanodeInfoProto_AdminState int32

const (
	DatanodeInfoProto_NORMAL                  DatanodeInfoProto_AdminState = 0
	DatanodeInfoProto_DECOMMISSION_INPROGRESS DatanodeInfoProto_AdminState = 1
	DatanodeInfoProto_DECOMMISSIONED          DatanodeInfoProto_AdminState = 2
)

var DatanodeInfoProto_AdminState_name = map[int32]string{
	0: "NORMAL",
	1: "DECOMMISSION_INPROGRESS",
	2: "DECOMMISSIONED",
}
var DatanodeInfoProto_AdminState_value = map[string]int32{
	"NORMAL":                  0,
	"DECOMMISSION_INPROGRESS": 1,
	"DECOMMISSIONED":          2,
}

func (x DatanodeInfoProto_AdminState) Enum() *DatanodeInfoProto_AdminState {
	p := new(DatanodeInfoProto_AdminState)
	*p = x
	return p
}
func (x DatanodeInfoProto_AdminState) String() string {
	return proto.EnumName(DatanodeInfoProto_AdminState_name, int32(x))
}
func (x *DatanodeInfoProto_AdminState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatanodeInfoProto_AdminState_value, data, "DatanodeInfoProto_AdminState")
	if err != nil {
		return err
	}
	*x = DatanodeInfoProto_AdminState(value)
	return nil
}

type DatanodeStorageProto_StorageState int32

const (
	DatanodeStorageProto_NORMAL           DatanodeStorageProto_StorageState = 0
	DatanodeStorageProto_READ_ONLY_SHARED DatanodeStorageProto_StorageState = 1
)

var DatanodeStorageProto_StorageState_name = map[int32]string{
	0: "NORMAL",
	1: "READ_ONLY_SHARED",
}
var DatanodeStorageProto_StorageState_value = map[string]int32{
	"NORMAL":           0,
	"READ_ONLY_SHARED": 1,
}

func (x DatanodeStorageProto_StorageState) Enum() *DatanodeStorageProto_StorageState {
	p := new(DatanodeStorageProto_StorageState)
	*p = x
	return p
}
func (x DatanodeStorageProto_StorageState) String() string {
	return proto.EnumName(DatanodeStorageProto_StorageState_name, int32(x))
}
func (x *DatanodeStorageProto_StorageState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatanodeStorageProto_StorageState_value, data, "DatanodeStorageProto_StorageState")
	if err != nil {
		return err
	}
	*x = DatanodeStorageProto_StorageState(value)
	return nil
}

type HdfsFileStatusProto_FileType int32

const (
	HdfsFileStatusProto_IS_DIR     HdfsFileStatusProto_FileType = 1
	HdfsFileStatusProto_IS_FILE    HdfsFileStatusProto_FileType = 2
	HdfsFileStatusProto_IS_SYMLINK HdfsFileStatusProto_FileType = 3
)

var HdfsFileStatusProto_FileType_name = map[int32]string{
	1: "IS_DIR",
	2: "IS_FILE",
	3: "IS_SYMLINK",
}
var HdfsFileStatusProto_FileType_value = map[string]int32{
	"IS_DIR":     1,
	"IS_FILE":    2,
	"IS_SYMLINK": 3,
}

func (x HdfsFileStatusProto_FileType) Enum() *HdfsFileStatusProto_FileType {
	p := new(HdfsFileStatusProto_FileType)
	*p = x
	return p
}
func (x HdfsFileStatusProto_FileType) String() string {
	return proto.EnumName(HdfsFileStatusProto_FileType_name, int32(x))
}
func (x *HdfsFileStatusProto_FileType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HdfsFileStatusProto_FileType_value, data, "HdfsFileStatusProto_FileType")
	if err != nil {
		return err
	}
	*x = HdfsFileStatusProto_FileType(value)
	return nil
}

// *
// Extended block idenfies a block
type ExtendedBlockProto struct {
	PoolId           *string `protobuf:"bytes,1,req,name=poolId" json:"poolId,omitempty"`
	BlockId          *uint64 `protobuf:"varint,2,req,name=blockId" json:"blockId,omitempty"`
	GenerationStamp  *uint64 `protobuf:"varint,3,req,name=generationStamp" json:"generationStamp,omitempty"`
	NumBytes         *uint64 `protobuf:"varint,4,opt,name=numBytes,def=0" json:"numBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExtendedBlockProto) Reset()         { *m = ExtendedBlockProto{} }
func (m *ExtendedBlockProto) String() string { return proto.CompactTextString(m) }
func (*ExtendedBlockProto) ProtoMessage()    {}

const Default_ExtendedBlockProto_NumBytes uint64 = 0

func (m *ExtendedBlockProto) GetPoolId() string {
	if m != nil && m.PoolId != nil {
		return *m.PoolId
	}
	return ""
}

func (m *ExtendedBlockProto) GetBlockId() uint64 {
	if m != nil && m.BlockId != nil {
		return *m.BlockId
	}
	return 0
}

func (m *ExtendedBlockProto) GetGenerationStamp() uint64 {
	if m != nil && m.GenerationStamp != nil {
		return *m.GenerationStamp
	}
	return 0
}

func (m *ExtendedBlockProto) GetNumBytes() uint64 {
	if m != nil && m.NumBytes != nil {
		return *m.NumBytes
	}
	return Default_ExtendedBlockProto_NumBytes
}

// *
// Identifies a Datanode
type DatanodeIDProto struct {
	IpAddr       *string `protobuf:"bytes,1,req,name=ipAddr" json:"ipAddr,omitempty"`
	HostName     *string `protobuf:"bytes,2,req,name=hostName" json:"hostName,omitempty"`
	DatanodeUuid *string `protobuf:"bytes,3,req,name=datanodeUuid" json:"datanodeUuid,omitempty"`
	// upgraded clusters this is the same
	// as the original StorageID of the
	// Datanode.
	XferPort         *uint32 `protobuf:"varint,4,req,name=xferPort" json:"xferPort,omitempty"`
	InfoPort         *uint32 `protobuf:"varint,5,req,name=infoPort" json:"infoPort,omitempty"`
	IpcPort          *uint32 `protobuf:"varint,6,req,name=ipcPort" json:"ipcPort,omitempty"`
	InfoSecurePort   *uint32 `protobuf:"varint,7,opt,name=infoSecurePort,def=0" json:"infoSecurePort,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatanodeIDProto) Reset()         { *m = DatanodeIDProto{} }
func (m *DatanodeIDProto) String() string { return proto.CompactTextString(m) }
func (*DatanodeIDProto) ProtoMessage()    {}

const Default_DatanodeIDProto_InfoSecurePort uint32 = 0

func (m *DatanodeIDProto) GetIpAddr() string {
	if m != nil && m.IpAddr != nil {
		return *m.IpAddr
	}
	return ""
}

func (m *DatanodeIDProto) GetHostName() string {
	if m != nil && m.HostName != nil {
		return *m.HostName
	}
	return ""
}

func (m *DatanodeIDProto) GetDatanodeUuid() string {
	if m != nil && m.DatanodeUuid != nil {
		return *m.DatanodeUuid
	}
	return ""
}

func (m *DatanodeIDProto) GetXferPort() uint32 {
	if m != nil && m.XferPort != nil {
		return *m.XferPort
	}
	return 0
}

func (m *DatanodeIDProto) GetInfoPort() uint32 {
	if m != nil && m.InfoPort != nil {
		return *m.InfoPort
	}
	return 0
}

func (m *DatanodeIDProto) GetIpcPort() uint32 {
	if m != nil && m.IpcPort != nil {
		return *m.IpcPort
	}
	return 0
}

func (m *DatanodeIDProto) GetInfoSecurePort() uint32 {
	if m != nil && m.InfoSecurePort != nil {
		return *m.InfoSecurePort
	}
	return Default_DatanodeIDProto_InfoSecurePort
}

// *
// Datanode local information
type DatanodeLocalInfoProto struct {
	SoftwareVersion  *string `protobuf:"bytes,1,req,name=softwareVersion" json:"softwareVersion,omitempty"`
	ConfigVersion    *string `protobuf:"bytes,2,req,name=configVersion" json:"configVersion,omitempty"`
	Uptime           *uint64 `protobuf:"varint,3,req,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatanodeLocalInfoProto) Reset()         { *m = DatanodeLocalInfoProto{} }
func (m *DatanodeLocalInfoProto) String() string { return proto.CompactTextString(m) }
func (*DatanodeLocalInfoProto) ProtoMessage()    {}

func (m *DatanodeLocalInfoProto) GetSoftwareVersion() string {
	if m != nil && m.SoftwareVersion != nil {
		return *m.SoftwareVersion
	}
	return ""
}

func (m *DatanodeLocalInfoProto) GetConfigVersion() string {
	if m != nil && m.ConfigVersion != nil {
		return *m.ConfigVersion
	}
	return ""
}

func (m *DatanodeLocalInfoProto) GetUptime() uint64 {
	if m != nil && m.Uptime != nil {
		return *m.Uptime
	}
	return 0
}

// *
// DatanodeInfo array
type DatanodeInfosProto struct {
	Datanodes        []*DatanodeInfoProto `protobuf:"bytes,1,rep,name=datanodes" json:"datanodes,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *DatanodeInfosProto) Reset()         { *m = DatanodeInfosProto{} }
func (m *DatanodeInfosProto) String() string { return proto.CompactTextString(m) }
func (*DatanodeInfosProto) ProtoMessage()    {}

func (m *DatanodeInfosProto) GetDatanodes() []*DatanodeInfoProto {
	if m != nil {
		return m.Datanodes
	}
	return nil
}

// *
// The status of a Datanode
type DatanodeInfoProto struct {
	Id                  *DatanodeIDProto              `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Capacity            *uint64                       `protobuf:"varint,2,opt,name=capacity,def=0" json:"capacity,omitempty"`
	DfsUsed             *uint64                       `protobuf:"varint,3,opt,name=dfsUsed,def=0" json:"dfsUsed,omitempty"`
	Remaining           *uint64                       `protobuf:"varint,4,opt,name=remaining,def=0" json:"remaining,omitempty"`
	BlockPoolUsed       *uint64                       `protobuf:"varint,5,opt,name=blockPoolUsed,def=0" json:"blockPoolUsed,omitempty"`
	LastUpdate          *uint64                       `protobuf:"varint,6,opt,name=lastUpdate,def=0" json:"lastUpdate,omitempty"`
	XceiverCount        *uint32                       `protobuf:"varint,7,opt,name=xceiverCount,def=0" json:"xceiverCount,omitempty"`
	Location            *string                       `protobuf:"bytes,8,opt,name=location" json:"location,omitempty"`
	AdminState          *DatanodeInfoProto_AdminState `protobuf:"varint,10,opt,name=adminState,enum=hadoop.hdfs.DatanodeInfoProto_AdminState,def=0" json:"adminState,omitempty"`
	CacheCapacity       *uint64                       `protobuf:"varint,11,opt,name=cacheCapacity,def=0" json:"cacheCapacity,omitempty"`
	CacheUsed           *uint64                       `protobuf:"varint,12,opt,name=cacheUsed,def=0" json:"cacheUsed,omitempty"`
	LastUpdateMonotonic *uint64                       `protobuf:"varint,13,opt,name=lastUpdateMonotonic,def=0" json:"lastUpdateMonotonic,omitempty"`
	UpgradeDomain       *string                       `protobuf:"bytes,14,opt,name=upgradeDomain" json:"upgradeDomain,omitempty"`
	XXX_unrecognized    []byte                        `json:"-"`
}

func (m *DatanodeInfoProto) Reset()         { *m = DatanodeInfoProto{} }
func (m *DatanodeInfoProto) String() string { return proto.CompactTextString(m) }
func (*DatanodeInfoProto) ProtoMessage()    {}

const Default_DatanodeInfoProto_Capacity uint64 = 0
const Default_DatanodeInfoProto_DfsUsed uint64 = 0
const Default_DatanodeInfoProto_Remaining uint64 = 0
const Default_DatanodeInfoProto_BlockPoolUsed uint64 = 0
const Default_DatanodeInfoProto_LastUpdate uint64 = 0
const Default_DatanodeInfoProto_XceiverCount uint32 = 0
const Default_DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState = DatanodeInfoProto_NORMAL
const Default_DatanodeInfoProto_CacheCapacity uint64 = 0
const Default_DatanodeInfoProto_CacheUsed uint64 = 0
const Default_DatanodeInfoProto_LastUpdateMonotonic uint64 = 0

func (m *DatanodeInfoProto) GetId() *DatanodeIDProto {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DatanodeInfoProto) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return Default_DatanodeInfoProto_Capacity
}

func (m *DatanodeInfoProto) GetDfsUsed() uint64 {
	if m != nil && m.DfsUsed != nil {
		return *m.DfsUsed
	}
	return Default_DatanodeInfoProto_DfsUsed
}

func (m *DatanodeInfoProto) GetRemaining() uint64 {
	if m != nil && m.Remaining != nil {
		return *m.Remaining
	}
	return Default_DatanodeInfoProto_Remaining
}

func (m *DatanodeInfoProto) GetBlockPoolUsed() uint64 {
	if m != nil && m.BlockPoolUsed != nil {
		return *m.BlockPoolUsed
	}
	return Default_DatanodeInfoProto_BlockPoolUsed
}

func (m *DatanodeInfoProto) GetLastUpdate() uint64 {
	if m != nil && m.LastUpdate != nil {
		return *m.LastUpdate
	}
	return Default_DatanodeInfoProto_LastUpdate
}

func (m *DatanodeInfoProto) GetXceiverCount() uint32 {
	if m != nil && m.XceiverCount != nil {
		return *m.XceiverCount
	}
	return Default_DatanodeInfoProto_XceiverCount
}

func (m *DatanodeInfoProto) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *DatanodeInfoProto) GetAdminState() DatanodeInfoProto_AdminState {
	if m != nil && m.AdminState != nil {
		return *m.AdminState
	}
	return Default_DatanodeInfoProto_AdminState
}

func (m *DatanodeInfoProto) GetCacheCapacity() uint64 {
	if m != nil && m.CacheCapacity != nil {
		return *m.CacheCapacity
	}
	return Default_DatanodeInfoProto_CacheCapacity
}

func (m *DatanodeInfoProto) GetCacheUsed() uint64 {
	if m != nil && m.CacheUsed != nil {
		return *m.CacheUsed
	}
	return Default_DatanodeInfoProto_CacheUsed
}

func (m *DatanodeInfoProto) GetLastUpdateMonotonic() uint64 {
	if m != nil && m.LastUpdateMonotonic != nil {
		return *m.LastUpdateMonotonic
	}
	return Default_DatanodeInfoProto_LastUpdateMonotonic
}

func (m *DatanodeInfoProto) GetUpgradeDomain() string {
	if m != nil && m.UpgradeDomain != nil {
		return *m.UpgradeDomain
	}
	return ""
}

// *
// Represents a storage available on the datanode
type DatanodeStorageProto struct {
	StorageUuid      *string                            `protobuf:"bytes,1,req,name=storageUuid" json:"storageUuid,omitempty"`
	State            *DatanodeStorageProto_StorageState `protobuf:"varint,2,opt,name=state,enum=hadoop.hdfs.DatanodeStorageProto_StorageState,def=0" json:"state,omitempty"`
	StorageType      *StorageTypeProto                  `protobuf:"varint,3,opt,name=storageType,enum=hadoop.hdfs.StorageTypeProto,def=1" json:"storageType,omitempty"`
	XXX_unrecognized []byte                             `json:"-"`
}

func (m *DatanodeStorageProto) Reset()         { *m = DatanodeStorageProto{} }
func (m *DatanodeStorageProto) String() string { return proto.CompactTextString(m) }
func (*DatanodeStorageProto) ProtoMessage()    {}

const Default_DatanodeStorageProto_State DatanodeStorageProto_StorageState = DatanodeStorageProto_NORMAL
const Default_DatanodeStorageProto_StorageType StorageTypeProto = StorageTypeProto_DISK

func (m *DatanodeStorageProto) GetStorageUuid() string {
	if m != nil && m.StorageUuid != nil {
		return *m.StorageUuid
	}
	return ""
}

func (m *DatanodeStorageProto) GetState() DatanodeStorageProto_StorageState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_DatanodeStorageProto_State
}

func (m *DatanodeStorageProto) GetStorageType() StorageTypeProto {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return Default_DatanodeStorageProto_StorageType
}

type StorageReportProto struct {
	StorageUuid      *string               `protobuf:"bytes,1,req,name=storageUuid" json:"storageUuid,omitempty"`
	Failed           *bool                 `protobuf:"varint,2,opt,name=failed,def=0" json:"failed,omitempty"`
	Capacity         *uint64               `protobuf:"varint,3,opt,name=capacity,def=0" json:"capacity,omitempty"`
	DfsUsed          *uint64               `protobuf:"varint,4,opt,name=dfsUsed,def=0" json:"dfsUsed,omitempty"`
	Remaining        *uint64               `protobuf:"varint,5,opt,name=remaining,def=0" json:"remaining,omitempty"`
	BlockPoolUsed    *uint64               `protobuf:"varint,6,opt,name=blockPoolUsed,def=0" json:"blockPoolUsed,omitempty"`
	Storage          *DatanodeStorageProto `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *StorageReportProto) Reset()         { *m = StorageReportProto{} }
func (m *StorageReportProto) String() string { return proto.CompactTextString(m) }
func (*StorageReportProto) ProtoMessage()    {}

const Default_StorageReportProto_Failed bool = false
const Default_StorageReportProto_Capacity uint64 = 0
const Default_StorageReportProto_DfsUsed uint64 = 0
const Default_StorageReportProto_Remaining uint64 = 0
const Default_StorageReportProto_BlockPoolUsed uint64 = 0

func (m *StorageReportProto) GetStorageUuid() string {
	if m != nil && m.StorageUuid != nil {
		return *m.StorageUuid
	}
	return ""
}

func (m *StorageReportProto) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return Default_StorageReportProto_Failed
}

func (m *StorageReportProto) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return Default_StorageReportProto_Capacity
}

func (m *StorageReportProto) GetDfsUsed() uint64 {
	if m != nil && m.DfsUsed != nil {
		return *m.DfsUsed
	}
	return Default_StorageReportProto_DfsUsed
}

func (m *StorageReportProto) GetRemaining() uint64 {
	if m != nil && m.Remaining != nil {
		return *m.Remaining
	}
	return Default_StorageReportProto_Remaining
}

func (m *StorageReportProto) GetBlockPoolUsed() uint64 {
	if m != nil && m.BlockPoolUsed != nil {
		return *m.BlockPoolUsed
	}
	return Default_StorageReportProto_BlockPoolUsed
}

func (m *StorageReportProto) GetStorage() *DatanodeStorageProto {
	if m != nil {
		return m.Storage
	}
	return nil
}

// *
// Summary of a file or directory
type ContentSummaryProto struct {
	Length           *uint64                     `protobuf:"varint,1,req,name=length" json:"length,omitempty"`
	FileCount        *uint64                     `protobuf:"varint,2,req,name=fileCount" json:"fileCount,omitempty"`
	DirectoryCount   *uint64                     `protobuf:"varint,3,req,name=directoryCount" json:"directoryCount,omitempty"`
	Quota            *uint64                     `protobuf:"varint,4,req,name=quota" json:"quota,omitempty"`
	SpaceConsumed    *uint64                     `protobuf:"varint,5,req,name=spaceConsumed" json:"spaceConsumed,omitempty"`
	SpaceQuota       *uint64                     `protobuf:"varint,6,req,name=spaceQuota" json:"spaceQuota,omitempty"`
	TypeQuotaInfos   *StorageTypeQuotaInfosProto `protobuf:"bytes,7,opt,name=typeQuotaInfos" json:"typeQuotaInfos,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *ContentSummaryProto) Reset()         { *m = ContentSummaryProto{} }
func (m *ContentSummaryProto) String() string { return proto.CompactTextString(m) }
func (*ContentSummaryProto) ProtoMessage()    {}

func (m *ContentSummaryProto) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *ContentSummaryProto) GetFileCount() uint64 {
	if m != nil && m.FileCount != nil {
		return *m.FileCount
	}
	return 0
}

func (m *ContentSummaryProto) GetDirectoryCount() uint64 {
	if m != nil && m.DirectoryCount != nil {
		return *m.DirectoryCount
	}
	return 0
}

func (m *ContentSummaryProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *ContentSummaryProto) GetSpaceConsumed() uint64 {
	if m != nil && m.SpaceConsumed != nil {
		return *m.SpaceConsumed
	}
	return 0
}

func (m *ContentSummaryProto) GetSpaceQuota() uint64 {
	if m != nil && m.SpaceQuota != nil {
		return *m.SpaceQuota
	}
	return 0
}

func (m *ContentSummaryProto) GetTypeQuotaInfos() *StorageTypeQuotaInfosProto {
	if m != nil {
		return m.TypeQuotaInfos
	}
	return nil
}

// *
// Summary of quota usage of a directory
type QuotaUsageProto struct {
	FileAndDirectoryCount *uint64                     `protobuf:"varint,1,req,name=fileAndDirectoryCount" json:"fileAndDirectoryCount,omitempty"`
	Quota                 *uint64                     `protobuf:"varint,2,req,name=quota" json:"quota,omitempty"`
	SpaceConsumed         *uint64                     `protobuf:"varint,3,req,name=spaceConsumed" json:"spaceConsumed,omitempty"`
	SpaceQuota            *uint64                     `protobuf:"varint,4,req,name=spaceQuota" json:"spaceQuota,omitempty"`
	TypeQuotaInfos        *StorageTypeQuotaInfosProto `protobuf:"bytes,5,opt,name=typeQuotaInfos" json:"typeQuotaInfos,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *QuotaUsageProto) Reset()         { *m = QuotaUsageProto{} }
func (m *QuotaUsageProto) String() string { return proto.CompactTextString(m) }
func (*QuotaUsageProto) ProtoMessage()    {}

func (m *QuotaUsageProto) GetFileAndDirectoryCount() uint64 {
	if m != nil && m.FileAndDirectoryCount != nil {
		return *m.FileAndDirectoryCount
	}
	return 0
}

func (m *QuotaUsageProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *QuotaUsageProto) GetSpaceConsumed() uint64 {
	if m != nil && m.SpaceConsumed != nil {
		return *m.SpaceConsumed
	}
	return 0
}

func (m *QuotaUsageProto) GetSpaceQuota() uint64 {
	if m != nil && m.SpaceQuota != nil {
		return *m.SpaceQuota
	}
	return 0
}

func (m *QuotaUsageProto) GetTypeQuotaInfos() *StorageTypeQuotaInfosProto {
	if m != nil {
		return m.TypeQuotaInfos
	}
	return nil
}

// *
// Storage type quota and usage information of a file or directory
type StorageTypeQuotaInfosProto struct {
	TypeQuotaInfo    []*StorageTypeQuotaInfoProto `protobuf:"bytes,1,rep,name=typeQuotaInfo" json:"typeQuotaInfo,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *StorageTypeQuotaInfosProto) Reset()         { *m = StorageTypeQuotaInfosProto{} }
func (m *StorageTypeQuotaInfosProto) String() string { return proto.CompactTextString(m) }
func (*StorageTypeQuotaInfosProto) ProtoMessage()    {}

func (m *StorageTypeQuotaInfosProto) GetTypeQuotaInfo() []*StorageTypeQuotaInfoProto {
	if m != nil {
		return m.TypeQuotaInfo
	}
	return nil
}

type StorageTypeQuotaInfoProto struct {
	Type             *StorageTypeProto `protobuf:"varint,1,req,name=type,enum=hadoop.hdfs.StorageTypeProto" json:"type,omitempty"`
	Quota            *uint64           `protobuf:"varint,2,req,name=quota" json:"quota,omitempty"`
	Consumed         *uint64           `protobuf:"varint,3,req,name=consumed" json:"consumed,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *StorageTypeQuotaInfoProto) Reset()         { *m = StorageTypeQuotaInfoProto{} }
func (m *StorageTypeQuotaInfoProto) String() string { return proto.CompactTextString(m) }
func (*StorageTypeQuotaInfoProto) ProtoMessage()    {}

func (m *StorageTypeQuotaInfoProto) GetType() StorageTypeProto {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return StorageTypeProto_DISK
}

func (m *StorageTypeQuotaInfoProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *StorageTypeQuotaInfoProto) GetConsumed() uint64 {
	if m != nil && m.Consumed != nil {
		return *m.Consumed
	}
	return 0
}

// *
// Contains a list of paths corresponding to corrupt files and a cookie
// used for iterative calls to NameNode.listCorruptFileBlocks.
//
type CorruptFileBlocksProto struct {
	Files            []string `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
	Cookie           *string  `protobuf:"bytes,2,req,name=cookie" json:"cookie,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CorruptFileBlocksProto) Reset()         { *m = CorruptFileBlocksProto{} }
func (m *CorruptFileBlocksProto) String() string { return proto.CompactTextString(m) }
func (*CorruptFileBlocksProto) ProtoMessage()    {}

func (m *CorruptFileBlocksProto) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *CorruptFileBlocksProto) GetCookie() string {
	if m != nil && m.Cookie != nil {
		return *m.Cookie
	}
	return ""
}

// *
// File or Directory permision - same spec as posix
type FsPermissionProto struct {
	Perm             *uint32 `protobuf:"varint,1,req,name=perm" json:"perm,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FsPermissionProto) Reset()         { *m = FsPermissionProto{} }
func (m *FsPermissionProto) String() string { return proto.CompactTextString(m) }
func (*FsPermissionProto) ProtoMessage()    {}

func (m *FsPermissionProto) GetPerm() uint32 {
	if m != nil && m.Perm != nil {
		return *m.Perm
	}
	return 0
}

// *
// A list of storage types.
type StorageTypesProto struct {
	StorageTypes     []StorageTypeProto `protobuf:"varint,1,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *StorageTypesProto) Reset()         { *m = StorageTypesProto{} }
func (m *StorageTypesProto) String() string { return proto.CompactTextString(m) }
func (*StorageTypesProto) ProtoMessage()    {}

func (m *StorageTypesProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

// *
// Block replica storage policy.
type BlockStoragePolicyProto struct {
	PolicyId *uint32 `protobuf:"varint,1,req,name=policyId" json:"policyId,omitempty"`
	Name     *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// a list of storage types for storing the block replicas when creating a
	// block.
	CreationPolicy *StorageTypesProto `protobuf:"bytes,3,req,name=creationPolicy" json:"creationPolicy,omitempty"`
	// A list of storage types for creation fallback storage.
	CreationFallbackPolicy    *StorageTypesProto `protobuf:"bytes,4,opt,name=creationFallbackPolicy" json:"creationFallbackPolicy,omitempty"`
	ReplicationFallbackPolicy *StorageTypesProto `protobuf:"bytes,5,opt,name=replicationFallbackPolicy" json:"replicationFallbackPolicy,omitempty"`
	XXX_unrecognized          []byte             `json:"-"`
}

func (m *BlockStoragePolicyProto) Reset()         { *m = BlockStoragePolicyProto{} }
func (m *BlockStoragePolicyProto) String() string { return proto.CompactTextString(m) }
func (*BlockStoragePolicyProto) ProtoMessage()    {}

func (m *BlockStoragePolicyProto) GetPolicyId() uint32 {
	if m != nil && m.PolicyId != nil {
		return *m.PolicyId
	}
	return 0
}

func (m *BlockStoragePolicyProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BlockStoragePolicyProto) GetCreationPolicy() *StorageTypesProto {
	if m != nil {
		return m.CreationPolicy
	}
	return nil
}

func (m *BlockStoragePolicyProto) GetCreationFallbackPolicy() *StorageTypesProto {
	if m != nil {
		return m.CreationFallbackPolicy
	}
	return nil
}

func (m *BlockStoragePolicyProto) GetReplicationFallbackPolicy() *StorageTypesProto {
	if m != nil {
		return m.ReplicationFallbackPolicy
	}
	return nil
}

// *
// A LocatedBlock gives information about a block and its location.
type LocatedBlockProto struct {
	B            *ExtendedBlockProto       `protobuf:"bytes,1,req,name=b" json:"b,omitempty"`
	Offset       *uint64                   `protobuf:"varint,2,req,name=offset" json:"offset,omitempty"`
	Locs         []*DatanodeInfoProto      `protobuf:"bytes,3,rep,name=locs" json:"locs,omitempty"`
	Corrupt      *bool                     `protobuf:"varint,4,req,name=corrupt" json:"corrupt,omitempty"`
	BlockToken   *hadoop_common.TokenProto `protobuf:"bytes,5,req,name=blockToken" json:"blockToken,omitempty"`
	IsCached     []bool                    `protobuf:"varint,6,rep,packed,name=isCached" json:"isCached,omitempty"`
	StorageTypes []StorageTypeProto        `protobuf:"varint,7,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	StorageIDs   []string                  `protobuf:"bytes,8,rep,name=storageIDs" json:"storageIDs,omitempty"`
	// striped block related fields
	BlockIndices     []byte                      `protobuf:"bytes,9,opt,name=blockIndices" json:"blockIndices,omitempty"`
	BlockTokens      []*hadoop_common.TokenProto `protobuf:"bytes,10,rep,name=blockTokens" json:"blockTokens,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *LocatedBlockProto) Reset()         { *m = LocatedBlockProto{} }
func (m *LocatedBlockProto) String() string { return proto.CompactTextString(m) }
func (*LocatedBlockProto) ProtoMessage()    {}

func (m *LocatedBlockProto) GetB() *ExtendedBlockProto {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *LocatedBlockProto) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *LocatedBlockProto) GetLocs() []*DatanodeInfoProto {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *LocatedBlockProto) GetCorrupt() bool {
	if m != nil && m.Corrupt != nil {
		return *m.Corrupt
	}
	return false
}

func (m *LocatedBlockProto) GetBlockToken() *hadoop_common.TokenProto {
	if m != nil {
		return m.BlockToken
	}
	return nil
}

func (m *LocatedBlockProto) GetIsCached() []bool {
	if m != nil {
		return m.IsCached
	}
	return nil
}

func (m *LocatedBlockProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

func (m *LocatedBlockProto) GetStorageIDs() []string {
	if m != nil {
		return m.StorageIDs
	}
	return nil
}

func (m *LocatedBlockProto) GetBlockIndices() []byte {
	if m != nil {
		return m.BlockIndices
	}
	return nil
}

func (m *LocatedBlockProto) GetBlockTokens() []*hadoop_common.TokenProto {
	if m != nil {
		return m.BlockTokens
	}
	return nil
}

type DataEncryptionKeyProto struct {
	KeyId               *uint32 `protobuf:"varint,1,req,name=keyId" json:"keyId,omitempty"`
	BlockPoolId         *string `protobuf:"bytes,2,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	Nonce               []byte  `protobuf:"bytes,3,req,name=nonce" json:"nonce,omitempty"`
	EncryptionKey       []byte  `protobuf:"bytes,4,req,name=encryptionKey" json:"encryptionKey,omitempty"`
	ExpiryDate          *uint64 `protobuf:"varint,5,req,name=expiryDate" json:"expiryDate,omitempty"`
	EncryptionAlgorithm *string `protobuf:"bytes,6,opt,name=encryptionAlgorithm" json:"encryptionAlgorithm,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *DataEncryptionKeyProto) Reset()         { *m = DataEncryptionKeyProto{} }
func (m *DataEncryptionKeyProto) String() string { return proto.CompactTextString(m) }
func (*DataEncryptionKeyProto) ProtoMessage()    {}

func (m *DataEncryptionKeyProto) GetKeyId() uint32 {
	if m != nil && m.KeyId != nil {
		return *m.KeyId
	}
	return 0
}

func (m *DataEncryptionKeyProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *DataEncryptionKeyProto) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *DataEncryptionKeyProto) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *DataEncryptionKeyProto) GetExpiryDate() uint64 {
	if m != nil && m.ExpiryDate != nil {
		return *m.ExpiryDate
	}
	return 0
}

func (m *DataEncryptionKeyProto) GetEncryptionAlgorithm() string {
	if m != nil && m.EncryptionAlgorithm != nil {
		return *m.EncryptionAlgorithm
	}
	return ""
}

// *
// Encryption information for a file.
type FileEncryptionInfoProto struct {
	Suite                 *CipherSuiteProto           `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	CryptoProtocolVersion *CryptoProtocolVersionProto `protobuf:"varint,2,req,name=cryptoProtocolVersion,enum=hadoop.hdfs.CryptoProtocolVersionProto" json:"cryptoProtocolVersion,omitempty"`
	Key                   []byte                      `protobuf:"bytes,3,req,name=key" json:"key,omitempty"`
	Iv                    []byte                      `protobuf:"bytes,4,req,name=iv" json:"iv,omitempty"`
	KeyName               *string                     `protobuf:"bytes,5,req,name=keyName" json:"keyName,omitempty"`
	EzKeyVersionName      *string                     `protobuf:"bytes,6,req,name=ezKeyVersionName" json:"ezKeyVersionName,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *FileEncryptionInfoProto) Reset()         { *m = FileEncryptionInfoProto{} }
func (m *FileEncryptionInfoProto) String() string { return proto.CompactTextString(m) }
func (*FileEncryptionInfoProto) ProtoMessage()    {}

func (m *FileEncryptionInfoProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *FileEncryptionInfoProto) GetCryptoProtocolVersion() CryptoProtocolVersionProto {
	if m != nil && m.CryptoProtocolVersion != nil {
		return *m.CryptoProtocolVersion
	}
	return CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION
}

func (m *FileEncryptionInfoProto) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FileEncryptionInfoProto) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *FileEncryptionInfoProto) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

func (m *FileEncryptionInfoProto) GetEzKeyVersionName() string {
	if m != nil && m.EzKeyVersionName != nil {
		return *m.EzKeyVersionName
	}
	return ""
}

// *
// Encryption information for an individual
// file within an encryption zone
type PerFileEncryptionInfoProto struct {
	Key              []byte  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Iv               []byte  `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	EzKeyVersionName *string `protobuf:"bytes,3,req,name=ezKeyVersionName" json:"ezKeyVersionName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PerFileEncryptionInfoProto) Reset()         { *m = PerFileEncryptionInfoProto{} }
func (m *PerFileEncryptionInfoProto) String() string { return proto.CompactTextString(m) }
func (*PerFileEncryptionInfoProto) ProtoMessage()    {}

func (m *PerFileEncryptionInfoProto) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *PerFileEncryptionInfoProto) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *PerFileEncryptionInfoProto) GetEzKeyVersionName() string {
	if m != nil && m.EzKeyVersionName != nil {
		return *m.EzKeyVersionName
	}
	return ""
}

// *
// Encryption information for an encryption
// zone
type ZoneEncryptionInfoProto struct {
	Suite                 *CipherSuiteProto           `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	CryptoProtocolVersion *CryptoProtocolVersionProto `protobuf:"varint,2,req,name=cryptoProtocolVersion,enum=hadoop.hdfs.CryptoProtocolVersionProto" json:"cryptoProtocolVersion,omitempty"`
	KeyName               *string                     `protobuf:"bytes,3,req,name=keyName" json:"keyName,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *ZoneEncryptionInfoProto) Reset()         { *m = ZoneEncryptionInfoProto{} }
func (m *ZoneEncryptionInfoProto) String() string { return proto.CompactTextString(m) }
func (*ZoneEncryptionInfoProto) ProtoMessage()    {}

func (m *ZoneEncryptionInfoProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *ZoneEncryptionInfoProto) GetCryptoProtocolVersion() CryptoProtocolVersionProto {
	if m != nil && m.CryptoProtocolVersion != nil {
		return *m.CryptoProtocolVersion
	}
	return CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION
}

func (m *ZoneEncryptionInfoProto) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

// *
// Cipher option
type CipherOptionProto struct {
	Suite            *CipherSuiteProto `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	InKey            []byte            `protobuf:"bytes,2,opt,name=inKey" json:"inKey,omitempty"`
	InIv             []byte            `protobuf:"bytes,3,opt,name=inIv" json:"inIv,omitempty"`
	OutKey           []byte            `protobuf:"bytes,4,opt,name=outKey" json:"outKey,omitempty"`
	OutIv            []byte            `protobuf:"bytes,5,opt,name=outIv" json:"outIv,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *CipherOptionProto) Reset()         { *m = CipherOptionProto{} }
func (m *CipherOptionProto) String() string { return proto.CompactTextString(m) }
func (*CipherOptionProto) ProtoMessage()    {}

func (m *CipherOptionProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *CipherOptionProto) GetInKey() []byte {
	if m != nil {
		return m.InKey
	}
	return nil
}

func (m *CipherOptionProto) GetInIv() []byte {
	if m != nil {
		return m.InIv
	}
	return nil
}

func (m *CipherOptionProto) GetOutKey() []byte {
	if m != nil {
		return m.OutKey
	}
	return nil
}

func (m *CipherOptionProto) GetOutIv() []byte {
	if m != nil {
		return m.OutIv
	}
	return nil
}

// *
// A set of file blocks and their locations.
type LocatedBlocksProto struct {
	FileLength          *uint64                  `protobuf:"varint,1,req,name=fileLength" json:"fileLength,omitempty"`
	Blocks              []*LocatedBlockProto     `protobuf:"bytes,2,rep,name=blocks" json:"blocks,omitempty"`
	UnderConstruction   *bool                    `protobuf:"varint,3,req,name=underConstruction" json:"underConstruction,omitempty"`
	LastBlock           *LocatedBlockProto       `protobuf:"bytes,4,opt,name=lastBlock" json:"lastBlock,omitempty"`
	IsLastBlockComplete *bool                    `protobuf:"varint,5,req,name=isLastBlockComplete" json:"isLastBlockComplete,omitempty"`
	FileEncryptionInfo  *FileEncryptionInfoProto `protobuf:"bytes,6,opt,name=fileEncryptionInfo" json:"fileEncryptionInfo,omitempty"`
	// Optional field for erasure coding
	EcPolicy         *ErasureCodingPolicyProto `protobuf:"bytes,7,opt,name=ecPolicy" json:"ecPolicy,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *LocatedBlocksProto) Reset()         { *m = LocatedBlocksProto{} }
func (m *LocatedBlocksProto) String() string { return proto.CompactTextString(m) }
func (*LocatedBlocksProto) ProtoMessage()    {}

func (m *LocatedBlocksProto) GetFileLength() uint64 {
	if m != nil && m.FileLength != nil {
		return *m.FileLength
	}
	return 0
}

func (m *LocatedBlocksProto) GetBlocks() []*LocatedBlockProto {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *LocatedBlocksProto) GetUnderConstruction() bool {
	if m != nil && m.UnderConstruction != nil {
		return *m.UnderConstruction
	}
	return false
}

func (m *LocatedBlocksProto) GetLastBlock() *LocatedBlockProto {
	if m != nil {
		return m.LastBlock
	}
	return nil
}

func (m *LocatedBlocksProto) GetIsLastBlockComplete() bool {
	if m != nil && m.IsLastBlockComplete != nil {
		return *m.IsLastBlockComplete
	}
	return false
}

func (m *LocatedBlocksProto) GetFileEncryptionInfo() *FileEncryptionInfoProto {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

func (m *LocatedBlocksProto) GetEcPolicy() *ErasureCodingPolicyProto {
	if m != nil {
		return m.EcPolicy
	}
	return nil
}

// *
// ECSchema options entry
type ECSchemaOptionEntryProto struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ECSchemaOptionEntryProto) Reset()         { *m = ECSchemaOptionEntryProto{} }
func (m *ECSchemaOptionEntryProto) String() string { return proto.CompactTextString(m) }
func (*ECSchemaOptionEntryProto) ProtoMessage()    {}

func (m *ECSchemaOptionEntryProto) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ECSchemaOptionEntryProto) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// ECSchema for erasurecoding
type ECSchemaProto struct {
	CodecName        *string                     `protobuf:"bytes,1,req,name=codecName" json:"codecName,omitempty"`
	DataUnits        *uint32                     `protobuf:"varint,2,req,name=dataUnits" json:"dataUnits,omitempty"`
	ParityUnits      *uint32                     `protobuf:"varint,3,req,name=parityUnits" json:"parityUnits,omitempty"`
	Options          []*ECSchemaOptionEntryProto `protobuf:"bytes,4,rep,name=options" json:"options,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *ECSchemaProto) Reset()         { *m = ECSchemaProto{} }
func (m *ECSchemaProto) String() string { return proto.CompactTextString(m) }
func (*ECSchemaProto) ProtoMessage()    {}

func (m *ECSchemaProto) GetCodecName() string {
	if m != nil && m.CodecName != nil {
		return *m.CodecName
	}
	return ""
}

func (m *ECSchemaProto) GetDataUnits() uint32 {
	if m != nil && m.DataUnits != nil {
		return *m.DataUnits
	}
	return 0
}

func (m *ECSchemaProto) GetParityUnits() uint32 {
	if m != nil && m.ParityUnits != nil {
		return *m.ParityUnits
	}
	return 0
}

func (m *ECSchemaProto) GetOptions() []*ECSchemaOptionEntryProto {
	if m != nil {
		return m.Options
	}
	return nil
}

type ErasureCodingPolicyProto struct {
	Name             *string        `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Schema           *ECSchemaProto `protobuf:"bytes,2,req,name=schema" json:"schema,omitempty"`
	CellSize         *uint32        `protobuf:"varint,3,req,name=cellSize" json:"cellSize,omitempty"`
	Id               *uint32        `protobuf:"varint,4,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ErasureCodingPolicyProto) Reset()         { *m = ErasureCodingPolicyProto{} }
func (m *ErasureCodingPolicyProto) String() string { return proto.CompactTextString(m) }
func (*ErasureCodingPolicyProto) ProtoMessage()    {}

func (m *ErasureCodingPolicyProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ErasureCodingPolicyProto) GetSchema() *ECSchemaProto {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *ErasureCodingPolicyProto) GetCellSize() uint32 {
	if m != nil && m.CellSize != nil {
		return *m.CellSize
	}
	return 0
}

func (m *ErasureCodingPolicyProto) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

// *
// Status of a file, directory or symlink
// Optionally includes a file's block locations if requested by client on the rpc call.
type HdfsFileStatusProto struct {
	FileType         *HdfsFileStatusProto_FileType `protobuf:"varint,1,req,name=fileType,enum=hadoop.hdfs.HdfsFileStatusProto_FileType" json:"fileType,omitempty"`
	Path             []byte                        `protobuf:"bytes,2,req,name=path" json:"path,omitempty"`
	Length           *uint64                       `protobuf:"varint,3,req,name=length" json:"length,omitempty"`
	Permission       *FsPermissionProto            `protobuf:"bytes,4,req,name=permission" json:"permission,omitempty"`
	Owner            *string                       `protobuf:"bytes,5,req,name=owner" json:"owner,omitempty"`
	Group            *string                       `protobuf:"bytes,6,req,name=group" json:"group,omitempty"`
	ModificationTime *uint64                       `protobuf:"varint,7,req,name=modification_time" json:"modification_time,omitempty"`
	AccessTime       *uint64                       `protobuf:"varint,8,req,name=access_time" json:"access_time,omitempty"`
	// Optional fields for symlink
	Symlink []byte `protobuf:"bytes,9,opt,name=symlink" json:"symlink,omitempty"`
	// Optional fields for file
	BlockReplication *uint32             `protobuf:"varint,10,opt,name=block_replication,def=0" json:"block_replication,omitempty"`
	Blocksize        *uint64             `protobuf:"varint,11,opt,name=blocksize,def=0" json:"blocksize,omitempty"`
	Locations        *LocatedBlocksProto `protobuf:"bytes,12,opt,name=locations" json:"locations,omitempty"`
	// Optional field for fileId
	FileId      *uint64 `protobuf:"varint,13,opt,name=fileId,def=0" json:"fileId,omitempty"`
	ChildrenNum *int32  `protobuf:"varint,14,opt,name=childrenNum,def=-1" json:"childrenNum,omitempty"`
	// Optional field for file encryption
	FileEncryptionInfo *FileEncryptionInfoProto `protobuf:"bytes,15,opt,name=fileEncryptionInfo" json:"fileEncryptionInfo,omitempty"`
	StoragePolicy      *uint32                  `protobuf:"varint,16,opt,name=storagePolicy,def=0" json:"storagePolicy,omitempty"`
	// Optional field for erasure coding
	EcPolicy         *ErasureCodingPolicyProto `protobuf:"bytes,17,opt,name=ecPolicy" json:"ecPolicy,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *HdfsFileStatusProto) Reset()         { *m = HdfsFileStatusProto{} }
func (m *HdfsFileStatusProto) String() string { return proto.CompactTextString(m) }
func (*HdfsFileStatusProto) ProtoMessage()    {}

const Default_HdfsFileStatusProto_BlockReplication uint32 = 0
const Default_HdfsFileStatusProto_Blocksize uint64 = 0
const Default_HdfsFileStatusProto_FileId uint64 = 0
const Default_HdfsFileStatusProto_ChildrenNum int32 = -1
const Default_HdfsFileStatusProto_StoragePolicy uint32 = 0

func (m *HdfsFileStatusProto) GetFileType() HdfsFileStatusProto_FileType {
	if m != nil && m.FileType != nil {
		return *m.FileType
	}
	return HdfsFileStatusProto_IS_DIR
}

func (m *HdfsFileStatusProto) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *HdfsFileStatusProto) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *HdfsFileStatusProto) GetPermission() *FsPermissionProto {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *HdfsFileStatusProto) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *HdfsFileStatusProto) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *HdfsFileStatusProto) GetModificationTime() uint64 {
	if m != nil && m.ModificationTime != nil {
		return *m.ModificationTime
	}
	return 0
}

func (m *HdfsFileStatusProto) GetAccessTime() uint64 {
	if m != nil && m.AccessTime != nil {
		return *m.AccessTime
	}
	return 0
}

func (m *HdfsFileStatusProto) GetSymlink() []byte {
	if m != nil {
		return m.Symlink
	}
	return nil
}

func (m *HdfsFileStatusProto) GetBlockReplication() uint32 {
	if m != nil && m.BlockReplication != nil {
		return *m.BlockReplication
	}
	return Default_HdfsFileStatusProto_BlockReplication
}

func (m *HdfsFileStatusProto) GetBlocksize() uint64 {
	if m != nil && m.Blocksize != nil {
		return *m.Blocksize
	}
	return Default_HdfsFileStatusProto_Blocksize
}

func (m *HdfsFileStatusProto) GetLocations() *LocatedBlocksProto {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *HdfsFileStatusProto) GetFileId() uint64 {
	if m != nil && m.FileId != nil {
		return *m.FileId
	}
	return Default_HdfsFileStatusProto_FileId
}

func (m *HdfsFileStatusProto) GetChildrenNum() int32 {
	if m != nil && m.ChildrenNum != nil {
		return *m.ChildrenNum
	}
	return Default_HdfsFileStatusProto_ChildrenNum
}

func (m *HdfsFileStatusProto) GetFileEncryptionInfo() *FileEncryptionInfoProto {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

func (m *HdfsFileStatusProto) GetStoragePolicy() uint32 {
	if m != nil && m.StoragePolicy != nil {
		return *m.StoragePolicy
	}
	return Default_HdfsFileStatusProto_StoragePolicy
}

func (m *HdfsFileStatusProto) GetEcPolicy() *ErasureCodingPolicyProto {
	if m != nil {
		return m.EcPolicy
	}
	return nil
}

// *
// HDFS Server Defaults
type FsServerDefaultsProto struct {
	BlockSize           *uint64            `protobuf:"varint,1,req,name=blockSize" json:"blockSize,omitempty"`
	BytesPerChecksum    *uint32            `protobuf:"varint,2,req,name=bytesPerChecksum" json:"bytesPerChecksum,omitempty"`
	WritePacketSize     *uint32            `protobuf:"varint,3,req,name=writePacketSize" json:"writePacketSize,omitempty"`
	Replication         *uint32            `protobuf:"varint,4,req,name=replication" json:"replication,omitempty"`
	FileBufferSize      *uint32            `protobuf:"varint,5,req,name=fileBufferSize" json:"fileBufferSize,omitempty"`
	EncryptDataTransfer *bool              `protobuf:"varint,6,opt,name=encryptDataTransfer,def=0" json:"encryptDataTransfer,omitempty"`
	TrashInterval       *uint64            `protobuf:"varint,7,opt,name=trashInterval,def=0" json:"trashInterval,omitempty"`
	ChecksumType        *ChecksumTypeProto `protobuf:"varint,8,opt,name=checksumType,enum=hadoop.hdfs.ChecksumTypeProto,def=1" json:"checksumType,omitempty"`
	XXX_unrecognized    []byte             `json:"-"`
}

func (m *FsServerDefaultsProto) Reset()         { *m = FsServerDefaultsProto{} }
func (m *FsServerDefaultsProto) String() string { return proto.CompactTextString(m) }
func (*FsServerDefaultsProto) ProtoMessage()    {}

const Default_FsServerDefaultsProto_EncryptDataTransfer bool = false
const Default_FsServerDefaultsProto_TrashInterval uint64 = 0
const Default_FsServerDefaultsProto_ChecksumType ChecksumTypeProto = ChecksumTypeProto_CHECKSUM_CRC32

func (m *FsServerDefaultsProto) GetBlockSize() uint64 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetBytesPerChecksum() uint32 {
	if m != nil && m.BytesPerChecksum != nil {
		return *m.BytesPerChecksum
	}
	return 0
}

func (m *FsServerDefaultsProto) GetWritePacketSize() uint32 {
	if m != nil && m.WritePacketSize != nil {
		return *m.WritePacketSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetReplication() uint32 {
	if m != nil && m.Replication != nil {
		return *m.Replication
	}
	return 0
}

func (m *FsServerDefaultsProto) GetFileBufferSize() uint32 {
	if m != nil && m.FileBufferSize != nil {
		return *m.FileBufferSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetEncryptDataTransfer() bool {
	if m != nil && m.EncryptDataTransfer != nil {
		return *m.EncryptDataTransfer
	}
	return Default_FsServerDefaultsProto_EncryptDataTransfer
}

func (m *FsServerDefaultsProto) GetTrashInterval() uint64 {
	if m != nil && m.TrashInterval != nil {
		return *m.TrashInterval
	}
	return Default_FsServerDefaultsProto_TrashInterval
}

func (m *FsServerDefaultsProto) GetChecksumType() ChecksumTypeProto {
	if m != nil && m.ChecksumType != nil {
		return *m.ChecksumType
	}
	return Default_FsServerDefaultsProto_ChecksumType
}

// *
// Directory listing
type DirectoryListingProto struct {
	PartialListing   []*HdfsFileStatusProto `protobuf:"bytes,1,rep,name=partialListing" json:"partialListing,omitempty"`
	RemainingEntries *uint32                `protobuf:"varint,2,req,name=remainingEntries" json:"remainingEntries,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *DirectoryListingProto) Reset()         { *m = DirectoryListingProto{} }
func (m *DirectoryListingProto) String() string { return proto.CompactTextString(m) }
func (*DirectoryListingProto) ProtoMessage()    {}

func (m *DirectoryListingProto) GetPartialListing() []*HdfsFileStatusProto {
	if m != nil {
		return m.PartialListing
	}
	return nil
}

func (m *DirectoryListingProto) GetRemainingEntries() uint32 {
	if m != nil && m.RemainingEntries != nil {
		return *m.RemainingEntries
	}
	return 0
}

// *
// Status of a snapshottable directory: besides the normal information for
// a directory status, also include snapshot quota, number of snapshots, and
// the full path of the parent directory.
type SnapshottableDirectoryStatusProto struct {
	DirStatus *HdfsFileStatusProto `protobuf:"bytes,1,req,name=dirStatus" json:"dirStatus,omitempty"`
	// Fields specific for snapshottable directory
	SnapshotQuota    *uint32 `protobuf:"varint,2,req,name=snapshot_quota" json:"snapshot_quota,omitempty"`
	SnapshotNumber   *uint32 `protobuf:"varint,3,req,name=snapshot_number" json:"snapshot_number,omitempty"`
	ParentFullpath   []byte  `protobuf:"bytes,4,req,name=parent_fullpath" json:"parent_fullpath,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SnapshottableDirectoryStatusProto) Reset()         { *m = SnapshottableDirectoryStatusProto{} }
func (m *SnapshottableDirectoryStatusProto) String() string { return proto.CompactTextString(m) }
func (*SnapshottableDirectoryStatusProto) ProtoMessage()    {}

func (m *SnapshottableDirectoryStatusProto) GetDirStatus() *HdfsFileStatusProto {
	if m != nil {
		return m.DirStatus
	}
	return nil
}

func (m *SnapshottableDirectoryStatusProto) GetSnapshotQuota() uint32 {
	if m != nil && m.SnapshotQuota != nil {
		return *m.SnapshotQuota
	}
	return 0
}

func (m *SnapshottableDirectoryStatusProto) GetSnapshotNumber() uint32 {
	if m != nil && m.SnapshotNumber != nil {
		return *m.SnapshotNumber
	}
	return 0
}

func (m *SnapshottableDirectoryStatusProto) GetParentFullpath() []byte {
	if m != nil {
		return m.ParentFullpath
	}
	return nil
}

// *
// Snapshottable directory listing
type SnapshottableDirectoryListingProto struct {
	SnapshottableDirListing []*SnapshottableDirectoryStatusProto `protobuf:"bytes,1,rep,name=snapshottableDirListing" json:"snapshottableDirListing,omitempty"`
	XXX_unrecognized        []byte                               `json:"-"`
}

func (m *SnapshottableDirectoryListingProto) Reset()         { *m = SnapshottableDirectoryListingProto{} }
func (m *SnapshottableDirectoryListingProto) String() string { return proto.CompactTextString(m) }
func (*SnapshottableDirectoryListingProto) ProtoMessage()    {}

func (m *SnapshottableDirectoryListingProto) GetSnapshottableDirListing() []*SnapshottableDirectoryStatusProto {
	if m != nil {
		return m.SnapshottableDirListing
	}
	return nil
}

// *
// Snapshot diff report entry
type SnapshotDiffReportEntryProto struct {
	Fullpath          []byte  `protobuf:"bytes,1,req,name=fullpath" json:"fullpath,omitempty"`
	ModificationLabel *string `protobuf:"bytes,2,req,name=modificationLabel" json:"modificationLabel,omitempty"`
	TargetPath        []byte  `protobuf:"bytes,3,opt,name=targetPath" json:"targetPath,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *SnapshotDiffReportEntryProto) Reset()         { *m = SnapshotDiffReportEntryProto{} }
func (m *SnapshotDiffReportEntryProto) String() string { return proto.CompactTextString(m) }
func (*SnapshotDiffReportEntryProto) ProtoMessage()    {}

func (m *SnapshotDiffReportEntryProto) GetFullpath() []byte {
	if m != nil {
		return m.Fullpath
	}
	return nil
}

func (m *SnapshotDiffReportEntryProto) GetModificationLabel() string {
	if m != nil && m.ModificationLabel != nil {
		return *m.ModificationLabel
	}
	return ""
}

func (m *SnapshotDiffReportEntryProto) GetTargetPath() []byte {
	if m != nil {
		return m.TargetPath
	}
	return nil
}

// *
// Snapshot diff report
type SnapshotDiffReportProto struct {
	// full path of the directory where snapshots were taken
	SnapshotRoot      *string                         `protobuf:"bytes,1,req,name=snapshotRoot" json:"snapshotRoot,omitempty"`
	FromSnapshot      *string                         `protobuf:"bytes,2,req,name=fromSnapshot" json:"fromSnapshot,omitempty"`
	ToSnapshot        *string                         `protobuf:"bytes,3,req,name=toSnapshot" json:"toSnapshot,omitempty"`
	DiffReportEntries []*SnapshotDiffReportEntryProto `protobuf:"bytes,4,rep,name=diffReportEntries" json:"diffReportEntries,omitempty"`
	XXX_unrecognized  []byte                          `json:"-"`
}

func (m *SnapshotDiffReportProto) Reset()         { *m = SnapshotDiffReportProto{} }
func (m *SnapshotDiffReportProto) String() string { return proto.CompactTextString(m) }
func (*SnapshotDiffReportProto) ProtoMessage()    {}

func (m *SnapshotDiffReportProto) GetSnapshotRoot() string {
	if m != nil && m.SnapshotRoot != nil {
		return *m.SnapshotRoot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetFromSnapshot() string {
	if m != nil && m.FromSnapshot != nil {
		return *m.FromSnapshot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetToSnapshot() string {
	if m != nil && m.ToSnapshot != nil {
		return *m.ToSnapshot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetDiffReportEntries() []*SnapshotDiffReportEntryProto {
	if m != nil {
		return m.DiffReportEntries
	}
	return nil
}

// *
// Block information
//
// Please be wary of adding additional fields here, since INodeFiles
// need to fit in PB's default max message size of 64MB.
// We restrict the max # of blocks per file
// (dfs.namenode.fs-limits.max-blocks-per-file), but it's better
// to avoid changing this.
type BlockProto struct {
	BlockId          *uint64 `protobuf:"varint,1,req,name=blockId" json:"blockId,omitempty"`
	GenStamp         *uint64 `protobuf:"varint,2,req,name=genStamp" json:"genStamp,omitempty"`
	NumBytes         *uint64 `protobuf:"varint,3,opt,name=numBytes,def=0" json:"numBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlockProto) Reset()         { *m = BlockProto{} }
func (m *BlockProto) String() string { return proto.CompactTextString(m) }
func (*BlockProto) ProtoMessage()    {}

const Default_BlockProto_NumBytes uint64 = 0

func (m *BlockProto) GetBlockId() uint64 {
	if m != nil && m.BlockId != nil {
		return *m.BlockId
	}
	return 0
}

func (m *BlockProto) GetGenStamp() uint64 {
	if m != nil && m.GenStamp != nil {
		return *m.GenStamp
	}
	return 0
}

func (m *BlockProto) GetNumBytes() uint64 {
	if m != nil && m.NumBytes != nil {
		return *m.NumBytes
	}
	return Default_BlockProto_NumBytes
}

// *
// Information related to a snapshot
// TODO: add more information
type SnapshotInfoProto struct {
	SnapshotName     *string            `protobuf:"bytes,1,req,name=snapshotName" json:"snapshotName,omitempty"`
	SnapshotRoot     *string            `protobuf:"bytes,2,req,name=snapshotRoot" json:"snapshotRoot,omitempty"`
	Permission       *FsPermissionProto `protobuf:"bytes,3,req,name=permission" json:"permission,omitempty"`
	Owner            *string            `protobuf:"bytes,4,req,name=owner" json:"owner,omitempty"`
	Group            *string            `protobuf:"bytes,5,req,name=group" json:"group,omitempty"`
	CreateTime       *string            `protobuf:"bytes,6,req,name=createTime" json:"createTime,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *SnapshotInfoProto) Reset()         { *m = SnapshotInfoProto{} }
func (m *SnapshotInfoProto) String() string { return proto.CompactTextString(m) }
func (*SnapshotInfoProto) ProtoMessage()    {}

func (m *SnapshotInfoProto) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *SnapshotInfoProto) GetSnapshotRoot() string {
	if m != nil && m.SnapshotRoot != nil {
		return *m.SnapshotRoot
	}
	return ""
}

func (m *SnapshotInfoProto) GetPermission() *FsPermissionProto {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *SnapshotInfoProto) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *SnapshotInfoProto) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *SnapshotInfoProto) GetCreateTime() string {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return ""
}

// *
// Rolling upgrade status
type RollingUpgradeStatusProto struct {
	BlockPoolId      *string `protobuf:"bytes,1,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	Finalized        *bool   `protobuf:"varint,2,opt,name=finalized,def=0" json:"finalized,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RollingUpgradeStatusProto) Reset()         { *m = RollingUpgradeStatusProto{} }
func (m *RollingUpgradeStatusProto) String() string { return proto.CompactTextString(m) }
func (*RollingUpgradeStatusProto) ProtoMessage()    {}

const Default_RollingUpgradeStatusProto_Finalized bool = false

func (m *RollingUpgradeStatusProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *RollingUpgradeStatusProto) GetFinalized() bool {
	if m != nil && m.Finalized != nil {
		return *m.Finalized
	}
	return Default_RollingUpgradeStatusProto_Finalized
}

// *
// A list of storage IDs.
type StorageUuidsProto struct {
	StorageUuids     []string `protobuf:"bytes,1,rep,name=storageUuids" json:"storageUuids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StorageUuidsProto) Reset()         { *m = StorageUuidsProto{} }
func (m *StorageUuidsProto) String() string { return proto.CompactTextString(m) }
func (*StorageUuidsProto) ProtoMessage()    {}

func (m *StorageUuidsProto) GetStorageUuids() []string {
	if m != nil {
		return m.StorageUuids
	}
	return nil
}

func init() {
	proto.RegisterEnum("hadoop.hdfs.StorageTypeProto", StorageTypeProto_name, StorageTypeProto_value)
	proto.RegisterEnum("hadoop.hdfs.CipherSuiteProto", CipherSuiteProto_name, CipherSuiteProto_value)
	proto.RegisterEnum("hadoop.hdfs.CryptoProtocolVersionProto", CryptoProtocolVersionProto_name, CryptoProtocolVersionProto_value)
	proto.RegisterEnum("hadoop.hdfs.ChecksumTypeProto", ChecksumTypeProto_name, ChecksumTypeProto_value)
	proto.RegisterEnum("hadoop.hdfs.DatanodeInfoProto_AdminState", DatanodeInfoProto_AdminState_name, DatanodeInfoProto_AdminState_value)
	proto.RegisterEnum("hadoop.hdfs.DatanodeStorageProto_StorageState", DatanodeStorageProto_StorageState_name, DatanodeStorageProto_StorageState_value)
	proto.RegisterEnum("hadoop.hdfs.HdfsFileStatusProto_FileType", HdfsFileStatusProto_FileType_name, HdfsFileStatusProto_FileType_value)
}
